<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoliSpace GS | Operational</title>
    
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.112/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.112/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/5.0.0/satellite.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Share Tech Mono', monospace; color: white; }
        #cesiumContainer { width: 100%; height: 100vh; }
        
        /* HUD */
        .hud {
            position: absolute; top: 10px; left: 10px;
            padding: 10px; background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00d4ff; z-index: 100;
        }
        .hud-title { color: #00d4ff; margin: 0 0 5px 0; font-size: 16px; border-bottom: 1px solid #333; }
        .log { font-size: 11px; color: #aaa; max-height: 100px; overflow-y: auto; }
        .ok { color: #0f0; } .err { color: #f00; }
    </style>
</head>
<body>

    <div class="hud">
        <h3 class="hud-title">GS STATUS</h3>
        <div class="log" id="sys-log"></div>
    </div>

    <div id="cesiumContainer"></div>

    <script>
        function sysLog(msg, type='') {
            const el = document.getElementById('sys-log');
            const color = type === 'err' ? '#f00' : (type === 'ok' ? '#0f0' : '#ccc');
            el.innerHTML = `<div style="color:${color}">> ${msg}</div>` + el.innerHTML;
        }

        // 1. INIZIALIZZAZIONE SICURA DEL VIEWER
        // Disabilitiamo l'imageryProvider automatico per evitare conflitti
        const viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider: false, // Partiamo con globo vuoto (blu/nero)
            baseLayerPicker: false, geocoder: false, homeButton: false, infoBox: false,
            sceneModePicker: false, selectionIndicator: true, timeline: false, animation: false,
            navigationHelpButton: false, shouldAnimate: true,
            contextOptions: { webgl: { alpha: true } }
        });

        // Configurazione Ambiente (Nero Spaziale)
        viewer.scene.skyBox.show = false;
        viewer.scene.backgroundColor = Cesium.Color.BLACK;
        viewer.scene.sun.show = false; // Nascondiamo il sole per illuminazione uniforme
        viewer.scene.globe.baseColor = Cesium.Color.BLACK;
        viewer.cesiumWidget.creditContainer.style.display = "none";

        // 2. CARICAMENTO MANUALE MAPPA (FIX "UNDEFINED")
        try {
            // Creiamo il provider
            const osmProvider = new Cesium.OpenStreetMapImageryProvider({
                url : 'https://a.tile.openstreetmap.org/'
            });
            
            // Aggiungiamo il layer e salviamo il riferimento
            const layer = viewer.imageryLayers.addImageryProvider(osmProvider);
            
            // ORA possiamo modificarlo perché 'layer' è la variabile che abbiamo appena creato
            layer.alpha = 1.0;
            layer.saturation = 0;       // Bianco e nero
            layer.brightness = 0.3;     // Molto scuro
            layer.contrast = 2.5;       // Alto contrasto per i confini

            sysLog("Map Layer loaded & styled.", "ok");
        } catch (e) {
            sysLog("Map Error: " + e.message, "err");
        }

        // Posizione Iniziale
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(12, 42, 10000000),
            orientation: { heading: 0.0, pitch: -1.57, roll: 0.0 }
        });

        // GS Milano Marker
        viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(9.2, 45.5),
            point: { pixelSize: 8, color: Cesium.Color.RED },
            label: { text: "GS MILANO", font: "12px Monospace", pixelOffset: new Cesium.Cartesian2(0, -20) }
        });

        // 3. TRACKING ORBITALE (Versione Stabile)
        const BACKUP_TLE = [
            { name: "ISS", l1: "1 25544U 98067A   24156.54672672  .00016503  00000+0  29765-3 0  9993", l2: "2 25544  51.6396 156.6874 0004739 233.8038 232.0673 15.49886026456636"},
            { name: "TIANGONG", l1: "1 48274U 21035A   24156.49503463  .00021308  00000+0  19198-3 0  9996", l2: "2 48274  41.4729 270.8351 0006764 250.6401 247.9628 15.60275811169094"},
            { name: "HUBBLE", l1: "1 20580U 90037B   24156.36884021  .00001888  00000+0  67586-4 0  9997", l2: "2 20580  28.4695 249.2078 0003025 258.9745 220.3013 15.09241416624966"}
        ];

        async function initSatellites() {
            sysLog("Fetching Orbital Data...", "info");
            try {
                // Proxy per evitare blocchi
                const url = 'https://corsproxy.io/?' + encodeURIComponent('https://celestrak.org/NORAD/elements/gp.php?GROUP=visual&FORMAT=tle');
                const resp = await fetch(url);
                if(!resp.ok) throw new Error("Network KO");
                const text = await resp.text();
                processData(text.split('\n'));
                sysLog("Live Data Loaded.", "ok");
            } catch (e) {
                sysLog("Live Data Fail. Using Backup.", "err");
                let dummy = [];
                BACKUP_TLE.forEach(s => { dummy.push(s.name, s.l1, s.l2); });
                processData(dummy);
            }
        }

        function processData(lines) {
            const start = Cesium.JulianDate.now();
            const stop = Cesium.JulianDate.addSeconds(start, 5400, new Cesium.JulianDate()); // +90 min

            // Setup Orologio
            viewer.clock.startTime = start.clone();
            viewer.clock.stopTime = stop.clone();
            viewer.clock.currentTime = start.clone();
            viewer.clock.multiplier = 10;
            viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;

            let count = 0;
            for(let i=0; i<lines.length; i++) {
                if(lines[i].startsWith('1 ') && lines[i+1]?.startsWith('2 ')) {
                    const name = lines[i-1]?.trim() || "SAT";
                    try {
                        addSatellite(name, lines[i], lines[i+1], start, stop);
                        count++;
                    } catch(e) {}
                }
            }
            sysLog("Tracking " + count + " objects.", "ok");
        }


function addSatellite(name, l1, l2, start, stop) {
    const satrec = satellite.twoline2satrec(l1, l2);
    const positions = new Cesium.SampledPositionProperty();
    
    // Campionamento posizione (uguale a prima)
    const totalSec = Cesium.JulianDate.secondsDifference(stop, start);
    for(let t=0; t<=totalSec; t+=60) {
        const time = Cesium.JulianDate.addSeconds(start, t, new Cesium.JulianDate());
        const jsDate = Cesium.JulianDate.toDate(time);
        
        const pv = satellite.propagate(satrec, jsDate);
        const gmst = satellite.gstime(jsDate);
        
        if(pv.position && gmst) {
            const gd = satellite.eciToGeodetic(pv.position, gmst);
            const cart = Cesium.Cartesian3.fromRadians(gd.longitude, gd.latitude, gd.height*1000);
            positions.addSample(time, cart);
        }
    }

    // CALCOLO ORIENTAMENTO (Novità!)
    // Fa sì che il satellite "guardi" avanti nella direzione in cui viaggia
    const orientation = new Cesium.VelocityOrientationProperty(positions);

    viewer.entities.add({
        name: name,
        position: positions,
        orientation: orientation, // Applica la rotazione fisica
        
        // MODELLO 3D (Invece del punto)
        model: {
            uri: 'satellite.glb', // Assicurati che questo file sia nella cartella!
            minimumPixelSize: 64, // Dimensione minima visibile
            maximumScale: 20000,  // Scala massima per non diventare enorme allo zoom
            runAnimations: true,  // Se il modello ha pannelli solari che si aprono
            shadows: Cesium.ShadowMode.ENABLED
        },

        // Scia Orbitale (Restata uguale, dà l'effetto velocità)
        path: {
            resolution: 1,
            width: 2,
            material: new Cesium.PolylineGlowMaterialProperty({
                glowPower: 0.2,
                color: Cesium.Color.CYAN
            }),
            leadTime: 0,
            trailTime: 5400 // Scia di 90 minuti
        },
        
        // Etichetta (Si vede solo quando ti avvicini)
        label: { 
            text: name, 
            font: "12px Share Tech Mono", 
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            outlineWidth: 2,
            verticalOrigin: Cesium.VerticalOrigin.TOP,
            pixelOffset: new Cesium.Cartesian2(0, 32), // Spostata sotto il modello
            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 2000000)
        }
    });
}
        setTimeout(initSatellites, 1000); // Avvio ritardato sicuro

    </script>
</body>
</html>