<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Satellite Tracking Hologram</title>
  <style>
    body { margin: 0; padding: 0; background-color: #000; overflow: hidden; }
    #globeViz { width: 100vw; height: 100vh; }
    
    /* Optional: A loading overlay */
    #loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: #0088ff; font-family: sans-serif; pointer-events: none;
      text-transform: uppercase; letter-spacing: 2px;
    }
  </style>

  <script src="//unpkg.com/three"></script>
  <script src="//unpkg.com/globe.gl"></script>
  <script src="//unpkg.com/satellite.js/dist/satellite.min.js"></script>
</head>
<body>

  <div id="loading">Initializing System...</div>
  <div id="globeViz"></div>

  <script>
    // --- CONFIGURATION ---
    const EARTH_RADIUS_KM = 6371; 
    const SAT_SIZE = 0.8;          // Size of the satellite dots
    const TIME_STEP = 1000;        // Animation speed helper
    const DOT_DENSITY = 0.4;       // How dense the earth surface dots are

    // --- 1. SETUP THE GLOBE ---
    const globeElement = document.getElementById('globeViz');
    
    const world = Globe()
      (globeElement)
      .backgroundColor('#000000')  // Pure black background
      .showGlobe(false)            // Hide the standard physical earth skin
      .atmosphereColor('#3a228a')  // Blue/Purple atmosphere
      .atmosphereAltitude(0.2)     // Atmosphere glow height
      
      // Setup the "Dot Matrix" Earth Layers
      .pointsData([]) // Will populate later
      .pointAltitude(0) // Flat on surface
      .pointColor(() => '#3a5fcd') // Blue dots for land
      .pointRadius(0.2) // Small dots
      .pointResolution(2); // Low poly for performance

    // --- 2. GENERATE EARTH DOTS (THE HOLOGRAPHIC LOOK) ---
    // We fetch a GeoJSON of landmasses, then generate random points inside them
    // to create the "tech grid" look without needing a heavy texture.
    fetch('//unpkg.com/world-atlas/countries-110m.json')
      .then(res => res.json())
      .then(worldData => {
        // We use a pre-calculated set of points for the grid effect 
        // using a hex-bin dataset often used in these visualizations.
        // This is a common trick to get the "dotted continent" look.
        fetch('//raw.githubusercontent.com/vasturiano/globe.gl/master/example/datasets/world_population.csv')
          .then(res => res.text())
          .then(csv => {
            const points = [];
            const rows = csv.split('\n');
            // Parse CSV, skipping header
            for (let i = 1; i < rows.length; i++) {
              if(!rows[i]) continue;
              const cols = rows[i].split(',');
              // Only take every Nth point to keep it looking like a grid, not a solid blob
              if (Math.random() > 0.8) { 
                points.push({ lat: +cols[2], lng: +cols[3], size: 0.1 });
              }
            }
            // Feed the dots to the globe
            world.pointsData(points);
            document.getElementById('loading').innerText = "Acquiring Orbital Data...";
          });
      });

    // --- 3. SATELLITE SETUP ---
    // Define how satellites look
    world.objectLat('lat')
      .objectLng('lng')
      .objectAltitude('alt')
      .objectLabel('name')
      .objectThreeObject(() => {
        // Create a small glowing sphere for each satellite
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(SAT_SIZE),
          new THREE.MeshBasicMaterial({ color: '#ff0055' }) // Pink/Red
        );
        return mesh;
      });

    // --- 4. FETCH SATELLITE DATA ---
    // Using a CORS proxy to bypass browser security restrictions on CelesTrak
    const PROXY_URL = 'https://corsproxy.io/?'; 
    const CELESTRAK_URL = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=active&FORMAT=tle';
    
    fetch(PROXY_URL + encodeURIComponent(CELESTRAK_URL))
      .then(r => r.text())
      .then(rawData => {
        const satData = parseTLE(rawData);
        
        // Load data into globe
        world.objectsData(satData);
        document.getElementById('loading').style.display = 'none';

        // Start Animation Loop
        (function tick() {
          updateSatellites(satData);
          world.objectsData(satData); // Trigger visual update
          requestAnimationFrame(tick);
        })();
      })
      .catch(err => {
        console.error("Failed to fetch TLE:", err);
        document.getElementById('loading').innerText = "Data Fetch Failed (Check Console)";
      });

    // --- 5. PARSER & MATH UTILITIES ---
    
    function parseTLE(data) {
      const lines = data.split('\n');
      const satData = [];
      // TLE standard is 3 lines: Name, Line 1, Line 2
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        // Look for the start of a TLE set (Line 1 usually starts with '1 ')
        // But often the file is Name \n Line1 \n Line2
        if (line.startsWith('1 ') && lines[i+1] && lines[i+1].startsWith('2 ')) {
          const name = lines[i-1] ? lines[i-1].trim() : "Unknown";
          const line1 = line;
          const line2 = lines[i+1].trim();
          
          try {
            const satRec = satellite.twoline2satrec(line1, line2);
            satData.push({
              satrec: satRec,
              name: name,
              lat: 0, lng: 0, alt: 0 
            });
          } catch (e) { /* ignore bad data */ }
        }
      }
      // Limit number of satellites for performance if needed (e.g. slice(0, 30))
      return satData;
    }

    function updateSatellites(satData) {
      const now = new Date();
      const gmst = satellite.gstime(now);

      satData.forEach(d => {
        // Propagate satellite to current time
        const positionAndVelocity = satellite.propagate(d.satrec, now);
        const positionEci = positionAndVelocity.position;

        if (positionEci) {
          const positionGd = satellite.eciToGeodetic(positionEci, gmst);
          
          d.lat = satellite.degreesLat(positionGd.latitude);
          d.lng = satellite.degreesLong(positionGd.longitude);
          // Altitude: Globe.gl expects altitude in terms of Globe Radius units.
          // Earth Radius = 6371km. If Sat is at 500km, val should be 500/6371.
          d.alt = positionGd.height / EARTH_RADIUS_KM;
        }
      });
    }

    // --- 6. INTERACTION ---
    // Enable auto-rotation
    world.controls().autoRotate = true;
    world.controls().autoRotateSpeed = 0.5;

  </script>
</body>
</html>

